# deployment.yaml - WIF Example for Hosted Cluster
#
# This deployment runs directly in the hosted cluster namespace.
# The pod uses a token-minter sidecar to mint JWT tokens for GCP WIF authentication.
#
# Prerequisites (created by setup-wif-example-gcp.sh):
#   1. GCP Workload Identity Pool and Provider configured with JWKS
#   2. GCP Service Account with appropriate IAM roles
#   3. WIF binding between K8s SA and GCP SA
#   4. credentials.json file generated
#
# To deploy:
#   kubectl apply -f deployment.yaml
#
# To check logs:
#   kubectl logs -n <namespace> -l app=wif-example -c wif-app -f

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: wif-app-workload-sa
  # This should match the namespace configured in your setup
  # Default from setup script: clusters-<INFRA_ID>
  namespace: clusters-my-hosted-cluster

---
# ConfigMap containing GCP credentials configuration for Workload Identity Federation
# 
# This ConfigMap should be created from the credentials.json file generated by:
#   ./setup-wif-example-gcp.sh
#
# Create it with:
#   kubectl create configmap gcp-wif-credentials \
#     --from-file=credentials.json=credentials.json \
#     -n clusters-my-hosted-cluster
#
# DO NOT apply this placeholder - it will be created from the generated credentials.json file
#
# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: gcp-wif-credentials
#   namespace: clusters-my-hosted-cluster
# data:
#   credentials.json: |
#     <Generated by setup script>

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wif-example-app
  namespace: clusters-my-hosted-cluster
  labels:
    app: wif-example
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wif-example
  template:
    metadata:
      labels:
        app: wif-example
    spec:
      # Use the service account bound to GCP via Workload Identity
      serviceAccountName: wif-app-workload-sa
      
      # Use existing pull secret in the namespace
      imagePullSecrets:
      - name: pull-secret
      
      volumes:
      # Shared volume for the minted token
      - name: token
        emptyDir: {}
      
      # Kubeconfig for token-minter to access the API server
      - name: kubeconfig
        secret:
          secretName: admin-kubeconfig
      
      # GCP WIF credentials configuration
      - name: gcp-credentials
        configMap:
          name: gcp-wif-credentials
      
      containers:
      # Main application container
      - name: wif-app
        image: gcr.io/<YOUR-PROJECT-ID>/wif-example:latest
        imagePullPolicy: IfNotPresent

        env:
        # GCP Project ID
        - name: GCP_PROJECT_ID
          value: "<YOUR-PROJECT-ID>"
        
        # Path to the token file (minted by sidecar)
        - name: TOKEN_FILE
          value: "/var/run/secrets/openshift/serviceaccount/token"
        
        # Token audience (must match WIF provider configuration)
        - name: TOKEN_AUDIENCE
          value: "openshift"
        
        # Point to the GCP credentials file
        - name: GOOGLE_APPLICATION_CREDENTIALS
          value: "/var/run/secrets/gcp/credentials.json"
        
        volumeMounts:
        # Mount token volume (read-only, written by token-minter)
        - name: token
          mountPath: /var/run/secrets/openshift/serviceaccount
          readOnly: true
        
        # Mount GCP credentials config
        - name: gcp-credentials
          mountPath: /var/run/secrets/gcp
          readOnly: true
        
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
      
      # Token minter sidecar - mints tokens for this SA with proper audience
      - name: token-minter
        # Requires imagePullSecret for Red Hat registry
        image: quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:290e11d20324aafaa5bf278dcda12486d08dc94a59e3cea158a7fced06d3e130
        imagePullPolicy: IfNotPresent
        
        volumeMounts:
        # Mount token volume (read-write, writes the token)
        - name: token
          mountPath: /var/run/secrets/openshift/serviceaccount
        
        # Mount kubeconfig to access the API server
        - name: kubeconfig
          mountPath: /etc/kubernetes
          readOnly: true
        
        command: ["/usr/bin/control-plane-operator", "token-minter"]
        args:
        # Mint tokens for the service account in the hosted cluster
        # Note: This runs in the management cluster but mints tokens in the hosted cluster
        - --service-account-namespace=default
        - --service-account-name=wif-app-workload-sa
        
        # Token audience (must match WIF provider configuration)
        - --token-audience=openshift
        
        # Where to write the minted token
        - --token-file=/var/run/secrets/openshift/serviceaccount/token
        
        # Path to kubeconfig
        - --kubeconfig=/etc/kubernetes/kubeconfig
        
        resources:
          requests:
            cpu: 10m
            memory: 30Mi
          limits:
            cpu: 50m
            memory: 50Mi

---
# RBAC for token-minter to create TokenRequest for the service account
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: wif-token-minter-role
  namespace: clusters-my-hosted-cluster
rules:
# Allow creating token requests for service accounts
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
# Allow reading service accounts
- apiGroups: [""]
  resources: ["serviceaccounts"]
  verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: wif-token-minter-rolebinding
  namespace: clusters-my-hosted-cluster
subjects:
- kind: ServiceAccount
  name: wif-app-workload-sa
  namespace: clusters-my-hosted-cluster
roleRef:
  kind: Role
  name: wif-token-minter-role
  apiGroup: rbac.authorization.k8s.io

---
# Optional: Additional RBAC if your app needs to access other Kubernetes resources
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: wif-example-app-role
  namespace: clusters-my-hosted-cluster
rules:
# Example: Allow reading configmaps
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: wif-example-app-rolebinding
  namespace: clusters-my-hosted-cluster
subjects:
- kind: ServiceAccount
  name: wif-app-workload-sa
  namespace: clusters-my-hosted-cluster
roleRef:
  kind: Role
  name: wif-example-app-role
  apiGroup: rbac.authorization.k8s.io
